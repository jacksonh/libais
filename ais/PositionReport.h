#ifndef AIS_POSITIONREPORT_H
#define AIS_POSITIONREPORT_H

// Based on https://github.com/schwehr/libais
// Copyright 2010 Kurt Schwehr.  Released under the LGPL v3
// 
// Additions copyright by Roland Arsenault 2012-2013

#include <cmath>

#include "Header.h"

namespace ais
{
    
/// Position Report (1,2 or 3)   
struct PositionReport: public Header
{
    /// Navigational status.
    /// 0 = under way using engine, 1 = at anchor, 2 = not under command, 
    /// 3 = restricted manoeuvrability, 4 = constrained by her draught, 
    /// 5 = moored, 6 = aground, 7 = engaged in fishing, 8 = under way 
    /// sailing, 9 = reserved for future amendment of navigational status for 
    /// ships carrying DG, HS, or MP, or IMO hazard or pollutant category C, 
    /// high speed craft (HSC), 10 = reserved for future amendment of 
    /// navigational status for ships carrying dangerous goods (DG), harmful 
    /// substances (HS) or marine pollutants (MP), or IMO hazard or pollutant 
    /// category A, wing in grand (WIG); 
    /// 11-13 = reserved for future use, 
    /// 14 = AIS-SART (active), 
    /// 15 = not defined = default  (also used by AIS-SART under test)
    int nav_status;
    
    /// Rate of turn (decoded).
    /// 0 to +126 = turning right at up to 708° per min or higher 
    /// 0 to –126 = turning left at up to 708° per min or higher  
    /// Values between 0 and 708° per min coded by  
    /// ROTAIS = 4.733 SQRT(ROTsensor) degrees per min 
    /// where ROTsensor is the Rate of Turn as input by an external Rate of 
    /// Turn Indicator (TI). ROTAIS is rounded to the nearest integer value
    /// +127 = turning right at more than 5º per 30 s (No TI available) 
    /// –127 = turning left at more than 5º per 30 s (No TI available) 
    /// –128 (80 hex) indicates no turn information available (default). 
    /// ROT data should not be derived from COG information. 
    float rot;

    /// No turn information available (default).
    bool rot_not_available;
    
    /// Rate of Turn Indicator (TI) not available.
    /// turning at more than 5º per 30 s
    bool rot_no_ti;
    
    /// SOG (decoded).
    /// Speed over ground in 1/10 knot steps (0-102.2 knots) 
    /// 1 023 = not available, 1 022 = 102.2 knots or higher
    float sog;
    
    bool sog_not_available;
    
    /// Position accuracy.
    /// The position accuracy (PA) flag should be determined in accordance 
    /// with Table 47 
    /// 1 = high (≤ 10 m)  
    /// 0 = low (>10 m) 
    /// 0 = default
    int position_accuracy;
    
    /// Longitude (decoded).
    /// Longitude in 1/10 000 min (±180º, East = positive (as per 2’s 
    /// complement), West = negative (as per 2’s complement).  
    /// 181= (6791AC0h) = not available = default) 
    float x;
    
    /// Latitude (decoded).
    /// Latitude in 1/10 000 min (±90°, North = positive (as per 2’s 
    /// complement), South = negative (as per 2’s complement). 91° 
    /// (3412140h) = not available = default) 
    float y;
    
    /// COG (decoded).
    /// Course over ground in 1/10 = (0-3599). 3600 (E10h) = not available 
    /// = default. 3 601-4 095 should not be used 
    float cog;
    
    /// True heading.
    /// Degrees (0-359) (511 indicates not available = default)
    int true_heading;
    
    /// Time stamp.
    /// UTC second when the report was generated by the electronic position 
    /// system (EPFS) (0-59, or 60 if time stamp is not available, which 
    /// should also be the default value, or 61 if positioning system is in 
    /// manual input mode, or 62 if electronic position fixing system 
    /// operates in estimated (dead reckoning) mode, or 63 if the positioning 
    /// system is inoperative)
    int timestamp;
    
    /// special manoeuvre indicator.
    /// 0 = not available = default 
    /// 1 = not engaged in special manoeuvre 
    /// 2 = engaged in special manoeuvre 
    /// (i.e.: regional passing arrangement on Inland Waterway) 
    int special_manoeuvre;
    
    /// Spare.
    /// Not used. Should be set to zero. Reserved for future use.
    int spare;
    
    /// RAIM-flag.
    /// Receiver autonomous integrity monitoring (RAIM) flag of electronic 
    /// position fixing device; 0 = RAIM not in use = default; 1 = RAIM in 
    /// use. See Table 47
    bool raim;
    
    PositionReport():nav_status(15),
        rot(0.0),rot_not_available(true),rot_no_ti(true),
        sog(0.0),sog_not_available(true),
        position_accuracy(0),
        x(181),y(91),
        cog(360),
        true_heading(511),
        timestamp(60),
        special_manoeuvre(0),
        spare(0),
        raim(0)
    {}
    
    PositionReport(const BinaryPayload &payload):nav_status(15),
        rot(0.0),rot_not_available(true),rot_no_ti(true),
        sog(0.0),sog_not_available(true),
        position_accuracy(0),
        x(181),y(91),
        cog(360),
        true_heading(511),
        timestamp(60),
        special_manoeuvre(0),
        spare(0),
        raim(0)
    {
        BinaryPayload::Cursor c = payload.new_cursor();
        decode(c);
    }
    
    void decode(BinaryPayload::Cursor &payload_cursor)
    {
        Header::decode(payload_cursor);
        
        nav_status = payload_cursor.uread(4);
        
        int rot_raw = payload_cursor.sread(8);
        if(rot_raw == -128)
        {
            rot_not_available = true;
            rot = 0.0;
        }
        else if(std::abs(rot_raw) == 127)
        {
            rot = 10.0;
            rot_no_ti = true;
            rot_not_available = false;
        }
        else
        {
            rot = pow( (rot_raw/4.733), 2 );
            rot_no_ti = false;
            rot_not_available = false;
        }
        
        if (rot_raw < 0) rot = -rot;
        
        int sog_raw = payload_cursor.uread(10);
        if(sog_raw == 1023)
        {
            sog = 0.0;
            sog_not_available = true;
        }
        else
        {
            sog = sog_raw / 10.;
            sog_not_available = false;
        }
        
        position_accuracy = payload_cursor.uread(1);
        
        int x_raw = payload_cursor.sread(28);
        if (x_raw == 0x6791AC0)
            x = 181;
        else
            x = x_raw / 600000.;
        
        int y_raw = payload_cursor.sread(27);
        if (y_raw == 0x3412140)
            y = 91;
        else
            y = y_raw / 600000.;
        
        cog = payload_cursor.sread(12) / 10.;
        
        true_heading = payload_cursor.uread(9);
        timestamp = payload_cursor.uread(6);
        special_manoeuvre = payload_cursor.uread(2);
        spare = payload_cursor.uread(3);
        raim = payload_cursor.uread(1);
    }
    
    /// Returns string description of Navigational status.
    std::string nav_status_str() const
    {
        switch(nav_status)
        {
            case 0:
                return "under way using engine";
            case 1:
                return "at anchor";
            case 2:
                return "not under command";
            case 3:
                return "restricted manoeuvrability";
            case 4:
                return "constrained by her draught";
            case 5:
                return "moored";
            case 6:
                return "aground";
            case 7:
                return "engaged in fishing";
            case 8:
                return "under way, sailing";
            case  9:
                return "reserved for future amendment of navigational status for ships carrying DG, HS, or MP, or IMO hazard or pollutant category C, high speed craft (HSC)";
            case 10:
                return "reserved for future amendment of navigational status for ships carrying dangerous goods (DG), harmful substances (HS) or marine pollutants (MP), or IMO hazard or pollutant category A, wing in grand (WIG)";
            case 11:
            case 12:
            case 13:
                return "reserved for future use";
            case 14:
                return "AIS-SART (active)";
            case 15:
                return "not defined";
        }
        return "invalid value";
    }
};


/// Position Report (1 or 2) with SOTDMA link information.
/// Scheduled position report; (Class A shipborne mobile equipment)
/// or
/// Assigned scheduled position report; (Class A shipborne mobile equipment)
struct PositionReport_SOTDMA: public PositionReport
{
    /// Sync state.
    /// 0 UTC direct (see 3.1.1.1)
    /// 1 UTC indirect (see 3.1.1.2)
    /// 2 Station is synchronized to a base station (base direct) (see 3.1.1.3)
    /// 3 Station is synchronized to another station based on the highest
    /// number of received stations or to another mobile station, which
    /// is directly synchronized to a base station (see 3.1.1.3 and 3.1.1.4)
    int sync_state;  
    
    /// Slot time-out.
    /// Specifies frames remaining until a new slot is selected 
    /// 0 means that this was the last transmission in this slot 
    /// 1-7 means that 1 to 7 frames respectively are left until slot change
    int slot_timeout;

    /// Received stations.
    /// Number of other stations (not own station) which the station 
    /// currently is receiving (between 0 and 16 383).
    int received_stations;
    
    /// Slot number.
    /// Slot number used for this transmission (between 0 and 2 249).
    int slot_number;
    
    /// UTC hour.
    /// If the station has access to UTC, the hour and minute should be 
    /// indicated in this sub message.
    int utc_hour;
    
    /// UTC minute.
    /// If the station has access to UTC, the hour and minute should be 
    /// indicated in this sub message.
    int utc_min;

    /// spare
    int utc_spare;

    /// Slot offset.
    /// If the slot time-out value is 0 (zero) then the slot offset should 
    /// indicate the offset to the slot in which transmission will occur 
    /// during the next frame. If the slot offset is zero, the slot should be 
    /// de-allocated after transmission.
    int slot_offset;
    
    PositionReport_SOTDMA()
        :sync_state(-1),slot_timeout(-1),received_stations(-1),slot_number(-1),utc_hour(-1),utc_min(-1),utc_spare(-1),slot_offset(-1)
    {}
    
    
    PositionReport_SOTDMA(const BinaryPayload &payload)
        :sync_state(-1),slot_timeout(-1),received_stations(-1),slot_number(-1),utc_hour(-1),utc_min(-1),utc_spare(-1),slot_offset(-1)
    {
        BinaryPayload::Cursor c = payload.new_cursor();
        decode(c);
    }
    
    void decode(BinaryPayload::Cursor &payload_cursor)
    {
        PositionReport::decode(payload_cursor);
        
        sync_state = payload_cursor.uread(2);
        slot_timeout = payload_cursor.uread(3);

        switch (slot_timeout) {
            case 0:
                slot_offset = payload_cursor.uread(14);
                break;
            case 1:
                utc_hour = payload_cursor.uread(5);
                utc_min = payload_cursor.uread(7);
                utc_spare = payload_cursor.uread(2);
                break;
            case 2: // FALLTHROUGH
            case 4: // FALLTHROUGH
            case 6:
                slot_number = payload_cursor.uread(14);
                break;
            case 3: // FALLTHROUGH
            case 5: // FALLTHROUGH
            case 7:
                received_stations = payload_cursor.uread(14);
                break;
        }
    }
};

/// Position Report (3) with ITDMA link information.
/// Special position report, response to interrogation; (Class A shipborne mobile equipment)
struct PositionReport_ITDMA: public PositionReport
{
    /// Sync state.
    /// 0 UTC direct (see 3.1.1.1) 
    /// 1 UTC indirect (see 3.1.1.2) 
    /// 2 Station is synchronized to a base station (base direct) (see 3.1.1.3)
    /// 3 Station is synchronized to another station based on the highest
    /// number of received stations or to another mobile station, which
    /// is directly synchronized to a base station (see 3.1.1.3 and 3.1.1.4)
    int sync_state;  

    /// Slot increment.
    /// Offset to next slot to be used, or zero (0) if no more transmissions
    int slot_increment;
    
    /// Number of slots.
    /// Number of consecutive slots to allocate.  
    /// 0 = 1 slot,  
    /// 1 = 2 slots, 
    /// 2 = 3 slots,  
    /// 3 = 4 slots,  
    /// 4 = 5 slots,  
    /// 5 = 1 slot; offset = slot increment + 8 192,  
    /// 6 = 2 slots; offset = slot increment + 8 192,  
    /// 7 = 3 slots; offset = slot increment + 8 192. 
    /// Use of 5 to 7 removes the need for RATDMA broadcast for 
    /// scheduled transmissions up to 6 min intervals
    int slots_to_allocate;
    
    /// Keep flag.
    /// Set to TRUE = 1 if the slot remains allocated for one additional 
    /// frame (see Table 13)
    bool keep_flag;  // 3.3.7.3.2 Annex 2 ITDMA.  Table 20

    PositionReport_ITDMA():sync_state(-1),slot_increment(-1),slots_to_allocate(-1),keep_flag(false){}
    
    PositionReport_ITDMA(const BinaryPayload &payload)
        :sync_state(-1),slot_increment(-1),slots_to_allocate(-1),keep_flag(false)
    {
        BinaryPayload::Cursor c = payload.new_cursor();
        decode(c);
    }
    
    void decode(BinaryPayload::Cursor &payload_cursor)
    {
        PositionReport::decode(payload_cursor);
        
        sync_state = payload_cursor.uread(2);
        slot_increment = payload_cursor.uread(13);
        slots_to_allocate = payload_cursor.uread(3);
        keep_flag = payload_cursor.uread(1);
    }
};

}

#endif
