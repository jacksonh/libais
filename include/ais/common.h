#ifndef AIS_COMMON_H
#define AIS_COMMON_H

// Based on https://github.com/schwehr/libais
// Copyright 2010 Kurt Schwehr.  Released under the LGPL v3
// 
// Additions copyright by Roland Arsenault 2012-2013

#include "BinaryPayload.h"

namespace ais
{
    struct LonLat
    {
        /// Longitude (decoded).
        /// Longitude in 1/10 000 min (±180º, East = positive (as per 2’s 
        /// complement), West = negative (as per 2’s complement).  
        /// 181= (6791AC0h) = not available = default) 
        float x;
        
        /// Latitude (decoded).
        /// Latitude in 1/10 000 min (±90°, North = positive (as per 2’s 
        /// complement), South = negative (as per 2’s complement). 91° 
        /// (3412140h) = not available = default) 
        float y;

        LonLat():x(181),y(91){}

        void decode(BinaryPayload::Cursor &payload_cursor)
        {
            int x_raw = payload_cursor.sread(28);
            if (x_raw == 0x6791AC0)
                x = 181;
            else
                x = x_raw / 600000.;

            int y_raw = payload_cursor.sread(27);
            if (y_raw == 0x3412140)
                y = 91;
            else
                y = y_raw / 600000.;
        }
    };

    struct LonLatAccuracy: public LonLat
    {
        /// Position accuracy.
        /// The position accuracy (PA) flag should be determined in accordance 
        /// with Table 47 
        /// 1 = high (≤ 10 m)  
        /// 0 = low (>10 m) 
        /// 0 = default
        int position_accuracy;
        
        LonLatAccuracy():position_accuracy(0){}
        
        void decode(BinaryPayload::Cursor &payload_cursor)
        {
            position_accuracy = payload_cursor.uread(1);
            LonLat::decode(payload_cursor);
        }
    };

    struct COG
    {
        /// COG (decoded).
        /// Course over ground in 1/10 = (0-3599). 3600 (E10h) = not available 
        /// = default. 3 601-4 095 should not be used 
        float cog;
        bool cog_not_available;
        
        COG():cog(360),cog_not_available(true){}

        void decode(BinaryPayload::Cursor &payload_cursor)
        {
            int cog_raw = payload_cursor.uread(12);

            cog_not_available = cog_raw == 0xe10;
            cog =  cog_raw / 10.;
        }
    };

    struct Timestamp
    {
        /// Time stamp.
        /// UTC second when the report was generated by the electronic position 
        /// system (EPFS) (0-59, or 60 if time stamp is not available, which 
        /// should also be the default value, or 61 if positioning system is in 
        /// manual input mode, or 62 if electronic position fixing system 
        /// operates in estimated (dead reckoning) mode, or 63 if the positioning 
        /// system is inoperative)
        int timestamp;

        Timestamp():timestamp(60){}

        void decode(BinaryPayload::Cursor &payload_cursor)
        {
            timestamp = payload_cursor.uread(6);
        }
    };

    struct RAIM
    {
        /// RAIM-flag.
        /// Receiver autonomous integrity monitoring (RAIM) flag of electronic 
        /// position fixing device; 0 = RAIM not in use = default; 1 = RAIM in 
        /// use. See Table 47
        bool raim;

        RAIM():raim(0){}

        void decode(BinaryPayload::Cursor &payload_cursor)
        {
            raim = payload_cursor.uread(1);
        }
    };
    
    struct SyncState
    {
        /// Sync state.
        /// 0 UTC direct (see 3.1.1.1)
        /// 1 UTC indirect (see 3.1.1.2)
        /// 2 Station is synchronized to a base station (base direct) (see 3.1.1.3)
        /// 3 Station is synchronized to another station based on the highest
        /// number of received stations or to another mobile station, which
        /// is directly synchronized to a base station (see 3.1.1.3 and 3.1.1.4)
        int sync_state;  

        SyncState():sync_state(-1){}

        void decode(BinaryPayload::Cursor &payload_cursor)
        {
            sync_state = payload_cursor.uread(2);
        }
    };

    struct SOTDMA
    {
        /// Slot time-out.
        /// Specifies frames remaining until a new slot is selected 
        /// 0 means that this was the last transmission in this slot 
        /// 1-7 means that 1 to 7 frames respectively are left until slot change
        int slot_timeout;
        
        /// Received stations.
        /// Number of other stations (not own station) which the station 
        /// currently is receiving (between 0 and 16 383).
        int received_stations;
        
        /// Slot number.
        /// Slot number used for this transmission (between 0 and 2 249).
        int slot_number;
        
        /// UTC hour.
        /// If the station has access to UTC, the hour and minute should be 
        /// indicated in this sub message.
        int utc_hour;
        
        /// UTC minute.
        /// If the station has access to UTC, the hour and minute should be 
        /// indicated in this sub message.
        int utc_min;
        
        /// spare
        int utc_spare;
        
        /// Slot offset.
        /// If the slot time-out value is 0 (zero) then the slot offset should 
        /// indicate the offset to the slot in which transmission will occur 
        /// during the next frame. If the slot offset is zero, the slot should be 
        /// de-allocated after transmission.
        int slot_offset;
        
        SOTDMA()
        :slot_timeout(-1),received_stations(-1),slot_number(-1),utc_hour(-1),utc_min(-1),utc_spare(-1),slot_offset(-1)
        {}
        
        void decode(BinaryPayload::Cursor &payload_cursor)
        {
            slot_timeout = payload_cursor.uread(3);

            switch (slot_timeout) {
                case 0:
                    slot_offset = payload_cursor.uread(14);
                    break;
                case 1:
                    utc_hour = payload_cursor.uread(5);
                    utc_min = payload_cursor.uread(7);
                    utc_spare = payload_cursor.uread(2);
                    break;
                case 2: // FALLTHROUGH
                case 4: // FALLTHROUGH
                case 6:
                    slot_number = payload_cursor.uread(14);
                    break;
                case 3: // FALLTHROUGH
                case 5: // FALLTHROUGH
                case 7:
                    received_stations = payload_cursor.uread(14);
                    break;
            }
        }
    };
    
    struct ITDMA
    {
        /// Slot increment.
        /// Offset to next slot to be used, or zero (0) if no more transmissions
        int slot_increment;
        
        /// Number of slots.
        /// Number of consecutive slots to allocate.  
        /// 0 = 1 slot,
        /// 1 = 2 slots,
        /// 2 = 3 slots,
        /// 3 = 4 slots,
        /// 4 = 5 slots,
        /// 5 = 1 slot; offset = slot increment + 8 192,
        /// 6 = 2 slots; offset = slot increment + 8 192,
        /// 7 = 3 slots; offset = slot increment + 8 192.
        /// Use of 5 to 7 removes the need for RATDMA broadcast for 
        /// scheduled transmissions up to 6 min intervals
        int slots_to_allocate;
        
        /// Keep flag.
        /// Set to TRUE = 1 if the slot remains allocated for one additional 
        /// frame (see Table 13)
        bool keep_flag;  // 3.3.7.3.2 Annex 2 ITDMA.  Table 20
        
        ITDMA():slot_increment(-1),slots_to_allocate(-1),keep_flag(false){}
        
        void decode(BinaryPayload::Cursor &payload_cursor)
        {
            slot_increment = payload_cursor.uread(13);
            slots_to_allocate = payload_cursor.uread(3);
            keep_flag = payload_cursor.uread(1);
        }
    };
        
    struct FixType
    {
        /// Type of electronic position fixing device.
        /// 0 = undefined (default)
        /// 1 = global positioning system (GPS)
        /// 2 = GNSS (GLONASS)
        /// 3 = combined GPS/GLONASS
        /// 4 = Loran-C
        /// 5 = Chayka
        /// 6 = integrated navigation system
        /// 7 = surveyed
        /// 8 = Galileo
        /// 9-14 = not used
        /// 15 = internal GNSS
        int fix_type;

        FixType():fix_type(0){}

        void decode(BinaryPayload::Cursor &payload_cursor)
        {
            fix_type = payload_cursor.uread(4);
        }

        std::string fix_type_str() const
        {
            switch(fix_type)
            {
                case 0:
                    return "undefined";
                case 1:
                    return "global positioning system (GPS)";
                case 2:
                    return "GNSS (GLONASS)";
                case 3:
                    return "combined GPS/GLONASS";
                case 4:
                    return "Loran-C";
                case 5:
                    return "Chayka";
                case 6:
                    return "integrated navigation system";
                case 7:
                    return "surveyed";
                case 8:
                    return "Galileo";
                case 15:
                    return "internal GNSS";
                default:
                    return "not used";
            }
            return "invalid fix type";
        }
        
    };
    
    struct DTE
    {
        /// DTE
        /// Data terminal equipment (DTE) ready (0 = available, 1 = not
        /// available = default) (see 3.3.1)
        int dte;

        DTE():dte(1){}

        void decode(BinaryPayload::Cursor &payload_cursor)
        {
            dte = payload_cursor.uread(1);
        }
    };

    struct Destination
    {
        /// Destination ID.
        /// MMSI number of destination station
        int dest_mmsi;

        Destination():dest_mmsi(-1){}

        void decode(BinaryPayload::Cursor &payload_cursor)
        {
            dest_mmsi = payload_cursor.uread(30);
        }
    };

    struct Addressed: public Destination
    {
        /// Sequence number.
        /// 0-3; refer to 5.3.1, Annex 2
        int seq;

        /// Retransmit flag.
        /// Retransmit flag should be set upon retransmission: 0 = no
        /// retransmission = default; 1 = retransmitted
        bool retransmit;

        /// Spare.
        /// Not used. Should be zero. Reserved for future use
        int spare;

        Addressed():seq(-1),retransmit(0),spare(0){}

        void decode(BinaryPayload::Cursor &payload_cursor)
        {
            seq = payload_cursor.uread(2);
            Destination::decode(payload_cursor);
            retransmit = payload_cursor.uread(1);
            spare = payload_cursor.uread(1);
        }
    };

    /// Application specific messages.
    /// AIS messages where the data content is defined by the application are application specific
    /// messages. Examples of this are the binary Messages 6 and 8. The data content does not affect the
    /// operation of the AIS. AIS is a means for transferring the data content between stations. A functional
    /// message's data structure consists of an application identifier (AI) followed by the application data.
    struct BinaryData
    {
        /// Designated area code (DAC).
        /// This code is based on the maritime identification digits (MID).
        /// Exceptions are 0 (test) and 1 (international). Although the length is 10 bits, the DAC codes
        /// equal to or above 1 000 are reserved for future use
        int dac;

        /// Function identifier.
        /// The meaning should be determined by the authority which is responsible
        /// for the area given in the designated area code
        int fi;

        /// Data content.
        /// variable length up to a given maximum.
        BinaryPayload payload;

        BinaryData():dac(-1),fi(-1){}

        void decode(BinaryPayload::Cursor &payload_cursor)
        {
            dac = payload_cursor.uread(10);
            fi = payload_cursor.uread(6);
            payload = payload_cursor.bin_read();
        }
    };

    struct GNSSDifferentialCorrectionData
    {
        /// Message type.
        /// Recommendation ITU-R M.823
        int msg_type;

        /// Station ID.
        /// Recommendation ITU-R M.823 station identifier
        int station_id;

        /// Z count.
        /// Time value in 0.6 s (0-3 599.4)
        float z_cnt;

        /// Sequence number.
        /// Message sequence number (cyclic 0-7)
        int seq_num;

        /// Health.
        /// Reference station health (specified in Recommendation ITU-R M.823)
        int health;

        std::vector<int> dgnss_data;
        
        GNSSDifferentialCorrectionData()
        :msg_type(-1),station_id(-1),z_cnt(-1),seq_num(-1)
        {}

        void decode(BinaryPayload::Cursor &payload_cursor)
        {
            msg_type = payload_cursor.uread(6);
            station_id = payload_cursor.uread(10);
            z_cnt = payload_cursor.uread(13)*0.6;
            seq_num = payload_cursor.uread(3);
            int n = payload_cursor.uread(5);
            health = payload_cursor.uread(3);
            for(int i = 0; i < n; ++i)
                dgnss_data.push_back(payload_cursor.uread(24));
        }
    };
}

#endif
